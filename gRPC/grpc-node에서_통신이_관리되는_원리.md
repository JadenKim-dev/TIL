# grpc-node에서 통신이 관리되는 원리

grpc-node 라이브러리는 Node.js에서 gRPC 클라이언트와 서버 간의 통신을 관리하는 역할을 합니다.  
grpc-node의 내부에서는 연결을 효율적으로 관리하기 위해 여러 가지 메커니즘을 사용합니다.

### **1. 채널(Channel) 관리**

- **채널 생성**: gRPC 클라이언트는 서버와의 통신을 위해 채널을 생성합니다. 이 채널은 여러 RPC 호출에서 재사용되며, 서버와의 물리적 연결을 나타냅니다.
- **연결 풀링(Connection Pooling)**: gRPC는 채널 내에서 여러 연결을 풀링(Pooling)하여 성능을 최적화합니다. 즉, 하나의 채널에 여러 물리적 연결이 있을 수 있으며, 클라이언트는 이 연결들을 통해 동시에 여러 RPC 호출을 처리할 수 있습니다.
- **부하 분산(Load Balancing)**: gRPC는 연결 풀 내에서 부하를 분산시키기 위해 연결을 순환시킬 수 있습니다. 이는 동일한 서버에 여러 연결이 필요하거나, 여러 서버에 요청을 분산시킬 때 유용합니다.

### **2. 연결 유지 및 재시도 관리**

- **연결 유지(Keepalive)**: gRPC는 주기적인 Ping을 통해 연결이 유지되고 있는지 확인하는 keepalive 메커니즘을 지원합니다. 이를 통해 비정상적인 연결이 끊어졌을 때 감지할 수 있습니다.
- **자동 재시도(Auto-retry)**: 클라이언트가 연결 실패를 감지하면 자동으로 재시도를 수행할 수 있습니다. gRPC는 이를 통해 클라이언트와 서버 간의 연결이 일시적으로 끊어지더라도, 재연결을 시도하여 안정적인 통신을 보장합니다.

### **3. 연결 종료 관리**

- **Graceful Shutdown**: gRPC 클라이언트나 서버가 종료될 때, 모든 기존 요청이 완료될 때까지 기다린 후 연결을 종료합니다. 이를 통해 갑작스러운 연결 종료로 인한 데이터 손실을 방지합니다.
- **채널 종료**: 클라이언트가 더 이상 서버와의 통신이 필요하지 않으면, 채널을 종료하여 모든 연결을 정리할 수 있습니다. 채널이 종료되면 연결 풀에 있는 모든 연결도 정리됩니다.

### **4. 보안 및 인증**

- **TLS 연결**: gRPC는 TLS를 통해 연결을 보호할 수 있으며, 이를 통해 안전한 데이터 전송을 보장합니다.
- **인증 관리**: gRPC는 채널 레벨에서 인증을 관리하며, 클라이언트와 서버 간의 안전한 인증을 위한 다양한 인증 방식을 지원합니다.

이러한 메커니즘을 통해 grpc-node는 클라이언트와 서버 간의 연결을 효율적으로 관리하며, 안정적인 통신을 보장합니다.

이 모든 과정은 대부분 라이브러리 내부에서 자동으로 관리되기 때문에, 개발자는 이러한 연결 관리 세부 사항을 신경 쓰지 않고도 gRPC의 기능을 활용할 수 있습니다.

## gRPC와 HTTP2 연결

gRPC는 기본적으로 HTTP/2를 기반으로 동작합니다. 따라서, gRPC 채널은 HTTP/2 연결을 유지합니다.

### **채널에서 유지되는 연결**

- **HTTP/2 연결**: gRPC는 HTTP/2 프로토콜을 사용하여 클라이언트와 서버 간의 통신을 관리합니다.
  채널이 생성되면 gRPC는 이 채널을 통해 하나의 HTTP/2 연결을 설정하고, 이 연결을 통해 여러 RPC 호출이 다중화됩니다.
  HTTP/2는 단일 TCP 연결을 통해 여러 스트림을 처리할 수 있는 멀티플렉싱 기능을 제공하므로, gRPC는 이를 통해 높은 효율성과 성능을 얻을 수 있습니다.
- **다중 스트림**: HTTP/2 연결은 단일 TCP 연결 위에서 여러 개의 스트림을 동시에 처리할 수 있습니다.
  gRPC 채널을 통해 이루어지는 각 RPC 호출은 HTTP/2 스트림으로 전송됩니다.
  이 스트림들은 독립적으로 관리되며, 하나의 채널에서 다수의 RPC 호출이 동시 다발적으로 이루어질 수 있습니다.

## HTTP2 프로토콜

HTTP/2(하이퍼텍스트 전송 프로토콜 버전 2)는 기존의 HTTP/1.x 프로토콜의 단점을 보완하고 웹 성능을 향상시키기 위해 개발된 프로토콜입니다.  
HTTP/2는 효율적인 웹 전송을 목표로 여러 가지 새로운 기능과 개선 사항을 도입했습니다.

1. **멀티플렉싱(Multiplexing):**  
HTTP/2는 하나의 연결에서 여러 요청과 응답을 동시에 처리할 수 있습니다. 이는 HTTP/1.x에서의 `단일 연결당 단일 요청/응답` 모델과는 큰 차이를 보이며, 여러 요청을 동시에 보내고 받을 수 있어 성능이 크게 향상됩니다.

2. **헤더 압축(Header Compression):**  
HTTP/2는 요청과 응답 헤더를 효율적으로 압축합니다. HPACK이라는 압축 방식을 사용하여 헤더 크기를 줄이고, 이를 통해 대역폭 사용을 최적화하고 전송 속도를 높입니다.

3. **서버 푸시(Server Push):**  
서버는 클라이언트가 요청하지 않은 리소스도 미리 전송할 수 있습니다. 예를 들어, 클라이언트가 HTML 파일을 요청하면 서버는 CSS나 JavaScript 파일도 함께 전송하여 페이지 로딩 속도를 높일 수 있습니다.

4. **스트림 우선순위(Stream Prioritization):**  
클라이언트는 여러 스트림에 우선순위를 부여할 수 있습니다. 이를 통해 중요한 리소스가 먼저 전송되고, 덜 중요한 리소스는 나중에 전송되어 웹 페이지 로딩이 최적화됩니다.

5. **연결 지속성 및 보안:**  
HTTP/2는 기본적으로 TLS(전송 계층 보안)를 사용하여 데이터의 기밀성과 무결성을 보장합니다. 또한, HTTP/2는 하나의 지속적인 연결에서 모든 요청과 응답을 처리할 수 있어 연결 설정 오버헤드가 감소합니다.

# 분산 락

Redis의 분산 락(distributed lock)은 여러 대의 서버나 프로세스가 동시에 같은 자원에 접근할 때, 데이터 일관성과 무결성을 보장하기 위해 사용하는 기술입니다.  
이는 특히 여러 대의 서버에서 동시성 제어가 필요한 환경에서 유용합니다.

### Redis 분산 락의 기본 개념

- **락 획득 (Acquire Lock):**  

클라이언트는 특정 리소스에 대한 락을 획득하기 위해 Redis에 키를 설정합니다.  
이 키는 일반적으로 리소스를 식별할 수 있는 유니크한 문자열입니다.  
락을 설정할 때, 만료 시간도 함께 설정하여 락이 무한정 지속되지 않도록 합니다.
  
- **락 해제 (Release Lock):**  

클라이언트가 작업을 마치면 해당 리소스에 대한 락을 해제합니다.  
이때, 락을 설정한 클라이언트만이 그 락을 해제할 수 있도록 해야 합니다.

- **락 재획득 (Renew Lock):**  

작업이 완료되기 전에 락의 만료 시간이 다가오는 경우, 락을 다시 획득하거나 만료 시간을 연장할 수 있습니다.  
그러나 이 작업은 조심해서 수행해야 합니다.

### Redis에서 분산 락을 구현하는 방법

Redis에서 분산 락을 구현하는 대표적인 방법은 `SETNX` 명령을 사용하는 것입니다.  
`SETNX`는 'SET if Not eXists'의 약자로, 해당 키가 존재하지 않는 경우에만 키를 설정합니다.  
이를 이용하여 락을 구현할 수 있습니다.

```plaintext
SETNX <lock_key> <client_id>
```

- `<lock_key>`는 락을 식별하는 유니크한 키입니다.
- `<client_id>`는 락을 설정하는 클라이언트를 식별할 수 있는 값입니다.

락 획득이 성공하면, 클라이언트는 자원에 접근할 수 있습니다.  
실패하면 다른 클라이언트가 락을 보유하고 있는 상태이므로, 잠시 대기한 후 다시 시도할 수 있습니다.

### 분산 락 구현 시 고려사항

1. **만료 시간 설정:**  

락을 영원히 소유하는 것을 방지하기 위해 TTL(Time To Live)을 설정해야 합니다.  
만료 시간이 지나면 Redis는 자동으로 락을 해제합니다.

2. **락 해제:**  

락을 해제할 때, 락을 설정한 클라이언트만이 해제할 수 있도록 하는 것이 중요합니다.  
이를 위해 스크립트를 사용하여 락을 설정한 클라이언트와 현재 해제하려는 클라이언트가 동일한지 확인하는 로직을 구현할 수 있습니다.

   ```lua
   if redis.call("get", KEYS[1]) == ARGV[1] then
       return redis.call("del", KEYS[1])
   else
       return 0
   end
   ```

위의 Lua 스크립트는 락을 해제할 때, 락을 설정한 클라이언트만이 `DEL` 명령을 실행할 수 있도록 합니다.

3. **Redlock 알고리즘:**  

단일 Redis 인스턴스에 락을 설정하는 것은 특정 인스턴스의 장애에 취약할 수 있습니다.  
이를 개선하기 위해 Redis의 창시자인 Salvatore Sanfilippo가 제안한 Redlock 알고리즘을 사용할 수 있습니다.  
Redlock은 여러 Redis 노드에 락을 분산하여 설정함으로써, 장애 상황에서도 안전한 락을 보장합니다.

### Redlock 알고리즘

Redlock 알고리즘은 다음과 같이 동작합니다:

1. 클라이언트는 N개의 Redis 노드에 동일한 락을 요청합니다.
2. 각 노드에 락을 요청할 때, 동일한 TTL을 설정하고, 요청에 대한 응답 시간을 기록합니다.
3. 클라이언트는 과반수 이상의 노드에서 락을 획득하면, 그 자원을 사용합니다.
4. 클라이언트는 작업을 마치면 락을 해제합니다.
5. 만약 클라이언트가 과반수 이상의 노드에서 락을 획득하지 못하면, 이미 획득한 락을 모두 해제하고, 일정 시간 대기한 후 다시 시도합니다.

Redlock 알고리즘은 높은 가용성과 신뢰성을 요구하는 분산 시스템에서 안전하게 락을 관리할 수 있는 방법으로 널리 사용됩니다.  
